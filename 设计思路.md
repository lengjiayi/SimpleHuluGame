## 2.设计思路
&nbsp;&nbsp;&nbsp;&nbsp;此版本和之前版本设计思路完全不同，采用了MVC设计模式，javaFx开发框架。下面从Model, View和Control三个方面简述设计思路。
### 2.1 资源管理
&nbsp;&nbsp;&nbsp;&nbsp;为了方便资源管理，将程序需要的所有属性和资源都封装到抽象类Configs和ViewBundle中。
- Configs中保存窗口布局相关的数值属性和游戏中人物贴图和其他游戏中使用的系统贴图，所有贴图通过ArrayList储存，并提供`static final int`下标按照如下命名格式进行索引。
```Java
    //贴图索引
    public static final int INDEX_PREBACKGROUND = 0;
    public static final int INDEX_BACKGROUND = 1;
    public static final int INDEX_START = 2;
    public static final int INDEX_LOAD = 3;
    public static final int INDEX_CLOSE = 4;
    public static final int INDEX_DCLOSE = 5;
    //...
    //布局属性
    public static int WIN_HEIGHT;
    public static int WIN_WIDTH;
    public static int TOP_MARAGIN;
    public static int BOTTOM_MARAGIN;
    public static int LEFT_MARGIN;
    public static int RIGHT_MARGIN;
    //...
```
- ViewBundle保存所有角色的攻击效果贴图，同样按照index寻址
## 3.0 MVC模式说明
### 3.1 模型Model
&nbsp;&nbsp;&nbsp;&nbsp;本游戏主要模型即角色（Charactor）。
#### 3.1.1 角色：
每个角色都运行在一个线程中，具有攻击力、HP、MP等战斗属性和当前位置、移动、存活等其他属性。Charactor的主要逻辑如下：
```Java
    /** 角色在真实画布上的位置*/
    public AtomicInteger PositionX=new AtomicInteger(0), PositionY=new AtomicInteger(0);
    /** 当前是否正在执行操作*/
    public AtomicBoolean avaliable=new AtomicBoolean(true);
    /** 用于接收命令*/
    public AtomicInteger cmd=new AtomicInteger(0);

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(50);
            } catch (Exception e) {
                e.printStackTrace();
            }
            cmdHandler();       //命令处理函数
        }
    }

    /** 在循环中等待新命令*/
    protected void cmdHandler()
    {
        switch (cmd.get())
        {
            case 0: break;                  //当前无任务
            case 1: WalkToDst(); cmd.set(0);break;       //1 号命令为移动到目的地
            case 2: Attack1(); cmd.set(0); break;        //2 号命令为普通攻击
            case 3: Attack2(); cmd.set(0); break;        //3 号命令为对群攻击
            case 4: Attack3(); cmd.set(0); break;        //4 号命令为必杀攻击
            default: break;
        }
    }
```
- 移动：角色移动过程中会在线程中定时更新自己的坐标和当前贴图的描述，OutlookManager定期使用对应的的贴图重绘即可形成移动的动画。
- 攻击：每个攻击效果(Bullet)对象具有自己的位置和贴图属性，Charactor通过一个静态类bulletController获得攻击效果移动的逻辑后更新Bullet的位置，OutlookManager定期将攻击效果绘制在Canvas上形成攻击动画。
### 3.2 视图View
&nbsp;&nbsp;&nbsp;&nbsp;在javaFx中我使用的主要视图控件为没有布局的Pane，游戏界面的主要控件如下：
- 场景Stage：
 - 场景中的Pane负责承载所有其他UI对象，并接收鼠标行为，并将MouseEvent传递给battleManager做出解析。
- 画布Canvas:
 - 画布用来绘制所有战斗动画效果并形成一个FPS动画，由视图控制类OutlookManager控制每秒更新36次，形成连贯动画。
- 技能栏SelectionBar：
 - 技能栏负责显示当前人物可用的技能，接收使用技能的命令，并传递给战斗控制类battleController处理。当前无选择角色时会隐藏，重新选中角色后battleManager会通知技能栏更新数据并弹出。
- 属性栏CInfoBar：
 - 属性栏负责显示当前鼠标经过的角色当前属性，内置一个计时器，会在无操作两秒后隐藏，battleManager在需要出现时通知属性栏弹出。
### 3.3 控制Control
&nbsp;&nbsp;&nbsp;&nbsp;游戏中主要的控制类有三个：控制战斗逻辑的battleManager，负责刷新界面的OutlookManager和负责控制敌人行为的Bot类，其中后两者都为前者的成员变量。所有控制类都有一个角色数组储存所有角色的引用。
- battleManager
 - battleManager会创建所有角色并开始其线程，其主要逻辑如下：
```Java
    static final int ACTION_CLICKED = 0;
    static final int ACTION_MOVEABOVE = 1;
    /** 接收一个鼠标事件*/
    public Charactor newAction(iPoint loc, int type)
    {
        //重放时不能控制角色
        if(type == ACTION_CLICKED && autoplaying)
            return null;
        for(Charactor x: creatures)
        {
            if(x.alive && x.avaliable.get())
            {
                iPoint vp = virtualField.rpTovp(x.PositionX.get()+Configs.B_SIZE/2, x.PositionY.get()+Configs.B_SIZE/2);
                if(loc.x==vp.x && loc.y==vp.y)
                {
                    if(type == ACTION_CLICKED)  //如果是点击则为选择一个人类角色
                        ChatSelected = x;
                    if(type == ACTION_MOVEABOVE || (!bind.get() && !x.monster))  //如果为鼠标经过则为显示角色属性
                        return x;
                 }
            }
        }
        if(type == ACTION_CLICKED) {
            if(ChatSelected!=null && ChatSelected.monster)
                ChatSelected = null;
            //TODO: 通知当前选中角色移动，保存玩家操作并减少玩家步数
            if(!bind.get() && ChatSelected != null)
            { ... }
        }
        return null;
    }

    /** 玩家步数减少1，并且判断是否轮到敌人进攻*/
    public void stepDecrease()
    {
        if(End)
            return;
        stepRemain--;           //步数减一
        view.hint.set(stepRemain);
        if(stepRemain==0)       //轮到妖怪回合
        {
            bind.set(true);     //禁用玩家操作
            new Thread(()->{
                while(true)     //等待所有角色结束当前行为
                { ... }
                bot.nextMove();  //阻塞等待怪物完成自己的回合
                bind.set(false); //启用玩家操作
            }).start();
            stepRemain = 3;
            view.hint.set(stepRemain);
        }
    }

    /** 游戏结束，通知View执行结束动画并终止战斗逻辑*/
    public void GameEnd(boolean monster)
    { ... }
```
- OutlookManager
 - OutlookManager本身为一个线程，每1/36s会重绘一次Canvas制作逐帧动画，需要注意的是所有与视图相关操作都需要在主线程中完成，这里在重绘时使用了Platform.runlater避免出现同步问题。
- Bot
 - Bot类封装的是电脑控制的妖怪战斗逻辑，提供`public void nextMove()`接口，计算、通知、并阻塞等待所有妖怪完成自己的行为。
## 4.0 其他重要组件
### 4.1 游戏保存
**SaveStack**负责保存游戏进度，提供如下接口：
```Java
    /**
     * 添加一次操作信息
     * @param chatId 角色ID
     * @param dstx 移动目的地横坐标
     * @param dsty 移动目的地纵坐标
     * @param type 操作类型
     */
    public void addMove(int chatId, int dstx, int dsty, int type)
```
每次玩家做出有效操作后battleManager或SelectionBar会调用此接口保存玩家操作，点击保存按钮后会将当前xml树写入文件。保存时采用xml文件，每一回合的格式如下：
```xml
  <round>
      <move ChatId="6" X="2" Y="4" type="walk">-1</move>
      <move ChatId="6" X="-1" Y="-1" type="attack">3</move>
      <move ChatId="6" X="-1" Y="-1" type="attack">1</move>
  </round>
```
### 4.2 读取进度
**AutoPlayer**负责解析xml文件并在线程中控制每个角色的行为，battleManager会一直设置禁用玩家操作直到读取结束（此线程结束）。
### 4.3 线程同步问题
- 所有只涉及同步读写的简单同步问题（如角色的位置）都使用Atomic变量保证同步。
- 所有视图相关操作都在主线程中完成。
- 属性栏和技能栏的自动弹出/消失存在较复杂的同步问题，如在弹出过程中接收到消失指令。这里使用两个Lock锁和一个boolean变量hide保证同步具体逻辑见CinfoBar.java或SelectionBar.java中的Hide和Showup方法。